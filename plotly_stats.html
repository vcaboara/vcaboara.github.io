<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WorkRave Statistics Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-2.20.0.min.js"></script>
    <style>
        /* CSS Variables for Dark Mode */
        :root {
            --body-bg: #f8f9fa;
            --body-text: #343a40;
            --filter-bg: #e9ecef;
            --filter-text: #343a40;
            --chart-bg: #ffffff;
            --chart-shadow: rgba(0,0,0,0.1);
            --header-color: #0056b3;
            --collapsible-header-bg: #e0e0e0;
            --collapsible-header-text: #343a40;
            --collapsible-header-hover-bg: #d0d0d0;
            --summary-bg: #f0f0f0;
            --summary-border: #cccccc;
            --group-header-bg: #dbe4ee; /* Light blue for group headers */
            --group-header-text: #0056b3;
            --query-bg: #e6f2ff; /* Light blue for query section */
            --query-border: #aed6f1;
        }

        body.dark-mode {
            --body-bg: #2c2c2c;
            --body-text: #e0e0e0;
            --filter-bg: #3a3a3a;
            --filter-text: #e0e0e0;
            --chart-bg: #3a3a3a;
            --chart-shadow: rgba(0,0,0,0.3);
            --header-color: #7bbaff; /* Lighter blue for dark mode */
            --collapsible-header-bg: #4a4a4a;
            --collapsible-header-text: #e0e0e0;
            --collapsible-header-hover-bg: #5a5a5a;
            --summary-bg: #333333;
            --summary-border: #555555;
            --group-header-bg: #4a4a4a; /* Darker blue for group headers in dark mode */
            --group-header-text: #7bbaff;
            --query-bg: #3a4a5a; /* Darker blue for query section */
            --query-border: #5a7a8a;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--body-bg);
            color: var(--body-text);
            transition: background-color 0.3s, color 0.3s;
        }
        h1 {
            color: var(--header-color);
            text-align: center;
            margin-bottom: 30px;
        }
        .filter-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background-color: var(--filter-bg);
            border-radius: 8px;
            justify-content: center;
            align-items: flex-start;
            transition: background-color 0.3s;
        }
        .query-controls {
            background-color: var(--query-bg);
            border: 1px solid var(--query-border);
            flex-direction: column;
            align-items: center;
            max-width: 1000px;
            margin: 20px auto;
            box-shadow: 0 2px 5px var(--chart-shadow);
        }
        .query-controls h3 {
            color: var(--header-color);
            margin-top: 0;
            margin-bottom: 10px;
        }
        .query-controls p {
            font-size: 0.9em;
            color: var(--body-text);
            text-align: center;
            margin-bottom: 15px;
        }
        .query-controls input[type="text"] {
            width: 80%;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--body-text);
            background-color: var(--chart-bg);
            color: var(--body-text);
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        .query-controls .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
            margin-top: 10px;
        }
        .query-controls button {
            padding: 10px 20px;
            border-radius: 4px;
            border: none;
            background-color: var(--header-color);
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        .query-controls button:hover {
            background-color: #004494;
        }
        #queryResults {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--summary-border);
            border-radius: 8px;
            background-color: var(--chart-bg);
            width: 90%;
            box-sizing: border-box;
            max-height: 200px; /* Limit height for scrollability */
            overflow-y: auto;
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
        }


        .filter-group {
            display: flex;
            align-items: center;
        }
        .filter-group.checkbox-group {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            margin-left: 20px;
        }
        .filter-group.checkbox-group div {
            display: flex;
            align-items: center;
        }
        .filter-group label {
            margin-right: 5px;
            font-weight: bold;
            color: var(--filter-text);
        }
        .filter-group input[type="date"],
        .filter-group button {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--body-text);
            background-color: var(--chart-bg);
            color: var(--body-text);
        }
        #darkModeToggle {
            margin-right: 8px;
        }

        /* Summary Statistics Section */
        .summary-stats-wrapper, .query-wrapper {
            max-width: 1000px;
            margin: 20px auto;
            background-color: var(--chart-bg); /* Match chart background for overall wrapper */
            border-radius: 8px;
            box-shadow: 0 2px 5px var(--chart-shadow);
            overflow: hidden; /* Ensures rounded corners are respected */
        }
        .summary-stats-container {
            background-color: var(--summary-bg);
            border-top: 1px solid var(--summary-border); /* Separator from header */
            border-bottom: 1px solid var(--summary-border); /* Separator below */
            padding: 20px;
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
        }
        .summary-stats-container h2 {
            display: none; /* Hide the h2 inside, as collapsible header will take over */
        }

        /* Grouping for Summary Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Adjust column width as needed */
            gap: 20px; /* Space between groups */
        }

        .stats-group {
            border: 1px solid var(--summary-border);
            border-radius: 8px;
            overflow: hidden;
            background-color: var(--chart-bg); /* Use chart bg for individual groups */
            box-shadow: 0 1px 3px var(--chart-shadow);
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
        }

        .stats-group h3 {
            background-color: var(--group-header-bg);
            color: var(--group-header-text);
            padding: 10px 15px;
            margin: 0;
            font-size: 1.1em;
            border-bottom: 1px solid var(--summary-border);
        }

        .stats-content {
            padding: 15px;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px dashed rgba(0,0,0,0.1);
            font-size: 1em;
        }
        body.dark-mode .stats-item {
            border-bottom: 1px dashed rgba(255,255,255,0.1);
        }
        .stats-item:last-child {
            border-bottom: none;
        }
        .stats-item span {
            font-weight: normal;
            color: var(--body-text);
        }

        .stats-group .comparison-notes {
            font-size: 0.9em; /* Smaller font for comparison notes */
            color: #6c757d; /* Lighter color for notes */
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed rgba(0,0,0,0.1);
        }
        body.dark-mode .stats-group .comparison-notes {
             color: #ced4da;
             border-top: 1px dashed rgba(255,255,255,0.1);
        }

        #chartContainer {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        .chart-wrapper {
            background-color: var(--chart-bg);
            border-radius: 8px;
            box-shadow: 0 2px 5px var(--chart-shadow);
            overflow: hidden;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .collapsible-header {
            background-color: var(--collapsible-header-bg);
            color: var(--collapsible-header-text);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            transition: background-color 0.2s, border-color 0.3s;
        }
        body.dark-mode .collapsible-header {
             border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .collapsible-header:hover {
            background-color: var(--collapsible-header-hover-bg);
        }
        .collapsible-header::after {
            content: '▼';
            font-size: 0.8em;
            margin-left: 10px;
            transition: transform 0.3s ease;
        }
        .collapsible-header.collapsed::after {
            content: '►';
            transform: rotate(0deg);
        }
        .collapsible-content {
            padding: 10px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        .collapsible-content.expanded {
            max-height: 2000px; /* Increased to accommodate more content */
            padding: 10px;
        }
        .chart-div {
            width: 100%;
            height: 350px;
            padding: 0;
            box-sizing: border-box;
        }

        .no-data-message {
            text-align: center;
            font-size: 1.2em;
            color: #dc3545;
            margin-top: 50px;
        }
    </style>
</head>
<body>
    <h1>WorkRave Activity & Break Statistics</h1>

    <div class="filter-controls">
        <div class="filter-group">
            <label for="startDate">Start Date:</label>
            <input type="date" id="startDate">
        </div>
        <div class="filter-group">
            <label for="endDate">End Date:</label>
            <input type="date" id="endDate">
        </div>
        <div class="filter-group checkbox-group">
            <label>Hide days with:</label>
            <div>
                <input type="checkbox" id="selectAllFilters">
                <label for="selectAllFilters">Select All Filters</label>
            </div>
            <div>
                <input type="checkbox" id="hideZeroActivityDays">
                <label for="hideZeroActivityDays">zero activity</label>
            </div>
            <div>
                <input type="checkbox" id="hideZeroUsageDays">
                <label for="hideZeroUsageDays">zero usage time</label>
            </div>
            <div>
                <input type="checkbox" id="hideNoBreakDataDays">
                <label for="hideNoBreakDataDays">no break data</label>
            </div>
            <div>
                <input type="checkbox" id="removeUsageOutliers">
                <label for="removeUsageOutliers">remove usage outliers (>24h)</label>
            </div>
        </div>
        <div class="filter-group">
            <input type="checkbox" id="darkModeToggle">
            <label for="darkModeToggle">Dark Mode</label>
        </div>
    </div>

    <div id="noDataMessage" class="no-data-message" style="display: none;">
        No data found for the selected filters.
    </div>

    <div class="summary-stats-wrapper">
        <div class="collapsible-header" onclick="toggleCollapse(this)">
            Summary Statistics (Filtered Data)
        </div>
        <div id="summaryStats" class="summary-stats-container collapsible-content expanded">
            <h2>Summary Statistics (Filtered Data)</h2> <div class="stats-grid">
                <div class="stats-group">
                    <h3>General</h3>
                    <div class="stats-content">
                        <div class="stats-item">Days in period: <span id="summaryDaysCount">N/A</span></div>
                        <h4 style="margin-top: 15px; margin-bottom: 5px; font-size: 1em;">Comparison (Office Worker)</h4>
                        <div class="stats-item">Avg Keystrokes: <span>2,000 - 4,000 / day</span></div>
                        <div class="stats-item">Avg Mouse Clicks: <span>1,500 - 8,000 / day</span></div>
                        <div class="stats-item">Avg Mouse Movement: <span>Data less common in units; typically >50% of computer time.</span></div>
                        <p class="comparison-notes">
                            *Estimates based on general studies and can vary by role/source.
                        </p>
                    </div>
                </div>

                <div class="stats-group">
                    <h3>Daily Usage (minutes/hours)</h3>
                    <div class="stats-content">
                        <div class="stats-item">Average: <span id="avgDailyUsage">N/A</span>/<span id="avgDailyUsageHours">N/A</span></div>
                        <div class="stats-item">Median: <span id="medianDailyUsage">N/A</span>/<span id="medianDailyUsageHours">N/A</span></div>
                        <div class="stats-item">Mode: <span id="modeDailyUsage">N/A</span>/<span id="modeDailyUsageHours">N/A</span></div>
                        <div class="stats-item">Max: <span id="maxDailyUsage">N/A</span>/<span id="maxDailyUsageHours">N/A</span></div>
                        <div class="stats-item">Min: <span id="minDailyUsage">N/A</span>/<span id="minDailyUsageHours">N/A</span></div>
                    </div>
                </div>

                <div class="stats-group">
                    <h3>Daily Keystrokes</h3>
                    <div class="stats-content">
                        <div class="stats-item">Average: <span id="avgDailyKeystrokes">N/A</span></div>
                        <div class="stats-item">Median: <span id="medianDailyKeystrokes">N/A</span></div>
                        <div class="stats-item">Mode: <span id="modeDailyKeystrokes">N/A</span></div>
                        <div class="stats-item">Max: <span id="maxDailyKeystrokes">N/A</span></div>
                        <div class="stats-item">Min: <span id="minDailyKeystrokes">N/A</span></div>
                    </div>
                </div>

                <div class="stats-group">
                    <h3>Daily Mouse Movement</h3>
                    <div class="stats-content">
                        <div class="stats-item">Average: <span id="avgDailyMouseMovement">N/A</span></div>
                        <div class="stats-item">Median: <span id="medianDailyMouseMovement">N/A</span></div>
                        <div class="stats-item">Max: <span id="maxDailyMouseMovement">N/A</span></div>
                        <div class="stats-item">Min: <span id="minDailyMouseMovement">N/A</span></div>
                    </div>
                </div>

                <div class="stats-group">
                    <h3>Daily Mouse Clicks</h3>
                    <div class="stats-content">
                        <div class="stats-item">Average: <span id="avgDailyMouseClicks">N/A</span></div>
                        <div class="stats-item">Median: <span id="medianDailyMouseClicks">N/A</span></div>
                        <div class="stats-item">Max: <span id="maxDailyMouseClicks">N/A</span></div>
                        <div class="stats-item">Min: <span id="minDailyMouseClicks">N/A</span></div>
                    </div>
                </div>

                <div class="stats-group">
                    <h3>Daily Break Duration (minutes)</h3>
                    <div class="stats-content">
                        <div class="stats-item">Average: <span id="avgDailyBreakDuration">N/A</span></div>
                        <div class="stats-item">Median: <span id="medianDailyBreakDuration">N/A</span></div>
                        <div class="stats-item">Mode: <span id="modeDailyBreakDuration">N/A</span></div>
                        <div class="stats-item">Max: <span id="maxDailyBreakDuration">N/A</span></div>
                        <div class="stats-item">Min: <span id="minDailyBreakDuration">N/A</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="query-wrapper">
        <div class="collapsible-header" onclick="toggleCollapse(this)">
            Custom Query
        </div>
        <div class="query-controls collapsible-content expanded">
            <p>Enter a query (e.g., "usage > 300", "keystrokes <= 10000"). <br>Available metrics: `usage`, `keystrokes`, `mouse_movement`, `mouse_clicks`, `break_duration`.</p>
            <input type="text" id="customQueryInput" placeholder="Enter your query here">
            <div class="button-group">
                <button id="runQueryButton">Run Query</button>
                <button id="downloadQueryResultsButton">Download CSV</button>
            </div>
            <div id="queryResults"></div>
        </div>
    </div>

    <div id="chartContainer">
        <div class="chart-wrapper">
            <div class="collapsible-header" onclick="toggleCollapse(this)">
                Daily Computer Usage Time
            </div>
            <div id="activityChart" class="chart-div collapsible-content expanded"></div>
        </div>

        <div class="chart-wrapper">
            <div class="collapsible-header" onclick="toggleCollapse(this)">
                Daily Keystrokes
            </div>
            <div id="keystrokeChart" class="chart-div collapsible-content expanded"></div>
        </div>

        <div class="chart-wrapper">
            <div class="collapsible-header" onclick="toggleCollapse(this)">
                Daily Mouse Movement
            </div>
            <div id="mouseMovementChart" class="chart-div collapsible-content expanded"></div>
        </div>

        <div class="chart-wrapper">
            <div class="collapsible-header" onclick="toggleCollapse(this)">
                Daily Mouse Clicks
            </div>
            <div id="mouseClickChart" class="chart-div collapsible-content expanded"></div>
        </div>

        <div class="chart-wrapper">
            <div class="collapsible-header" onclick="toggleCollapse(this)">
                Daily Total Break Duration
            </div>
            <div id="breakDurationChart" class="chart-div collapsible-content expanded"></div>
        </div>
    </div>

    <script>
        const DEFAULT_START_DATE = "2023-08-21";
        const DEFAULT_END_DATE = "2025-04-16";
        const JSON_DATA_URL = 'https://vcaboara.github.io/workrave_stats.json';

        // Define outlier threshold (e.g., 24 hours in minutes)
        const USAGE_OUTLIER_THRESHOLD_MINUTES = 1440;

        let allWorkRaveData = [];
        let currentFilteredData = []; // Store filtered data to be used by queries
        let lastQueryResults = []; // Store the results of the last custom query

        async function fetchInitialData() {
            try {
                const response = await fetch(JSON_DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                allWorkRaveData = await response.json();
                console.log("Initial data fetched:", allWorkRaveData.length, "entries.");
            } catch (error) {
                console.error('Error fetching WorkRave data:', error);
                document.body.innerHTML = "<p style='text-align: center; color: red;'>Failed to load WorkRave data from " + JSON_DATA_URL + ". Please ensure the file exists and is accessible.</p>";
                return;
            }
        }

        function toggleCollapse(headerElement) {
            headerElement.classList.toggle('collapsed');
            const content = headerElement.nextElementSibling;
            content.classList.toggle('expanded');
            // For plotly charts, relayout if they are expanded to ensure they render correctly
            if (content.classList.contains('expanded')) {
                // Check if the content contains plotly charts (chart-div class)
                const chartDivs = content.querySelectorAll('.chart-div');
                chartDivs.forEach(chartDiv => {
                    if (chartDiv.dataset.plotlyInitialised === 'true') { // Only relayout if chart was drawn
                        Plotly.relayout(chartDiv.id, {});
                    }
                });
            }
        }

        function getIndividualFilterCheckboxes() {
            return [
                document.getElementById('hideZeroActivityDays'),
                document.getElementById('hideZeroUsageDays'),
                document.getElementById('hideNoBreakDataDays'),
                document.getElementById('removeUsageOutliers')
            ];
        }

        function saveFilterState() {
            localStorage.setItem('startDate', document.getElementById('startDate').value);
            localStorage.setItem('endDate', document.getElementById('endDate').value);
            localStorage.setItem('hideZeroActivityDays', document.getElementById('hideZeroActivityDays').checked);
            localStorage.setItem('hideZeroUsageDays', document.getElementById('hideZeroUsageDays').checked);
            localStorage.setItem('hideNoBreakDataDays', document.getElementById('hideNoBreakDataDays').checked);
            localStorage.setItem('removeUsageOutliers', document.getElementById('removeUsageOutliers').checked);
            localStorage.setItem('darkModeToggle', document.getElementById('darkModeToggle').checked);
        }

        function loadFilterState() {
            const startDate = localStorage.getItem('startDate');
            const endDate = localStorage.getItem('endDate');
            const hideZeroActivityDays = localStorage.getItem('hideZeroActivityDays');
            const hideZeroUsageDays = localStorage.getItem('hideZeroUsageDays');
            const hideNoBreakDataDays = localStorage.getItem('hideNoBreakDataDays');
            const removeUsageOutliers = localStorage.getItem('removeUsageOutliers');
            const darkModeToggle = localStorage.getItem('darkModeToggle');

            if (startDate) document.getElementById('startDate').value = startDate;
            if (endDate) document.getElementById('endDate').value = endDate;
            
            // For checkboxes, localStorage returns strings "true" or "false"
            if (hideZeroActivityDays !== null) document.getElementById('hideZeroActivityDays').checked = (hideZeroActivityDays === 'true');
            if (hideZeroUsageDays !== null) document.getElementById('hideZeroUsageDays').checked = (hideZeroUsageDays === 'true');
            if (hideNoBreakDataDays !== null) document.getElementById('hideNoBreakDataDays').checked = (hideNoBreakDataDays === 'true');
            if (removeUsageOutliers !== null) document.getElementById('removeUsageOutliers').checked = (removeUsageOutliers === 'true');
            
            // Dark mode toggle
            if (darkModeToggle !== null) {
                const isDarkMode = (darkModeToggle === 'true');
                document.getElementById('darkModeToggle').checked = isDarkMode;
                if (isDarkMode) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
            }
        }

        async function applyFiltersAndRenderCharts() {
            document.getElementById('noDataMessage').style.display = 'none';

            let filteredData = [...allWorkRaveData];

            const startDateInput = document.getElementById('startDate').value;
            const endDateInput = document.getElementById('endDate').value;

            const startDateFilter = startDateInput ? new Date(startDateInput + 'T00:00:00') : new Date(0);
            const endDateFilter = endDateInput ? new Date(endDateInput + 'T23:59:59') : new Date();

            filteredData = filteredData.filter(entry => {
                if (!entry.start_date) return false;

                const entryDate = new Date(Date.UTC(entry.start_date.year, entry.start_date.month, entry.start_date.day));
                const entryDateStartOfDay = new Date(entryDate.getFullYear(), entryDate.getMonth(), entryDate.getDate());
                const entryDateEndOfDay = new Date(entryDate.getFullYear(), entryDate.getMonth(), entryDate.getDate(), 23, 59, 59, 999);

                return entryDateStartOfDay >= startDateFilter && entryDateEndOfDay <= endDateFilter;
            });

            const hideZeroActivityDays = document.getElementById('hideZeroActivityDays').checked;
            if (hideZeroActivityDays) {
                filteredData = filteredData.filter(entry => {
                    const activity = entry.activity_stats;
                    return (activity && (activity.keystrokes > 0 || activity.mouse_movement_units > 0 || activity.mouse_clicks > 0));
                });
            }

            const hideZeroUsageDays = document.getElementById('hideZeroUsageDays').checked;
            if (hideZeroUsageDays) {
                filteredData = filteredData.filter(entry => {
                    const startDateTime = new Date(entry.start_date.year, entry.start_date.month, entry.start_date.day, entry.start_time.hour, entry.start_time.minute);
                    const endDateTime = new Date(entry.end_date.year, entry.end_date.month, entry.end_date.day, entry.end_time.hour, entry.end_time.minute);
                    const durationMs = endDateTime - startDateTime;
                    const usageMinutes = durationMs / (1000 * 60);
                    return usageMinutes > 0;
                });
            }

            const hideNoBreakDataDays = document.getElementById('hideNoBreakDataDays').checked;
            if (hideNoBreakDataDays) {
                filteredData = filteredData.filter(entry => {
                    if (!entry.break_stats || entry.break_stats.length === 0) {
                        return false;
                    }
                    const totalBreakDuration = entry.break_stats.reduce((sum, b) => sum + (b.values && b.values.length > 1 ? b.values[1] : 0), 0);
                    return totalBreakDuration > 0;
                });
            }

            const removeUsageOutliers = document.getElementById('removeUsageOutliers').checked;
            if (removeUsageOutliers) {
                filteredData = filteredData.filter(entry => {
                    const startDateTime = new Date(entry.start_date.year, entry.start_date.month, entry.start_date.day, entry.start_time.hour, entry.start_time.minute);
                    const endDateTime = new Date(entry.end_date.year, entry.end_date.month, entry.end_date.day, entry.end_time.hour, entry.end_time.minute);
                    const durationMs = endDateTime - startDateTime;
                    const usageMinutes = durationMs / (1000 * 60);
                    return usageMinutes <= USAGE_OUTLIER_THRESHOLD_MINUTES;
                });
            }

            filteredData.sort((a, b) => {
                const dateA = new Date(a.start_date.year, a.start_date.month, a.start_date.day);
                const dateB = new Date(b.start_date.year, b.start_date.month, b.start_date.day);
                return dateA - dateB;
            });

            currentFilteredData = filteredData; // Store for custom queries

            if (currentFilteredData.length === 0) {
                document.getElementById('noDataMessage').style.display = 'block';
                // Clear charts
                ['activityChart', 'keystrokeChart', 'mouseMovementChart', 'mouseClickChart', 'breakDurationChart'].forEach(id => {
                    Plotly.newPlot(id, [], {});
                    document.getElementById(id).dataset.plotlyInitialised = 'false';
                });
                updateSummaryStatistics([]);
                document.getElementById('queryResults').textContent = 'No data to query.';
                lastQueryResults = []; // Clear previous query results
                return;
            }

            updateSummaryStatistics(currentFilteredData);
            renderPlotlyCharts(currentFilteredData);
            // Re-run any custom query if there's one in the input field
            runCustomQuery();
            saveFilterState(); // Save state after applying filters
        }

        /**
         * Calculates the median of an array of numbers.
         * @param {number[]} arr The input array.
         * @returns {number|string} The median, or 'N/A' if the array is empty.
         */
        function calculateMedian(arr) {
            if (arr.length === 0) return 'N/A';
            const sortedArr = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sortedArr.length / 2);
            if (sortedArr.length % 2 === 0) {
                return (sortedArr[mid - 1] + sortedArr[mid]) / 2;
            }
            return sortedArr[mid];
        }

        /**
         * Calculates the mode(s) of an array of numbers.
         * @param {number[]} arr The input array.
         * @returns {string} A string representation of the mode(s), or 'N/A' if empty/no mode.
         */
        function calculateMode(arr) {
            if (arr.length === 0) return 'N/A';

            const counts = {};
            arr.forEach(num => {
                counts[num] = (counts[num] || 0) + 1;
            });

            let maxCount = 0;
            for (const num in counts) {
                if (counts[num] > maxCount) {
                    maxCount = counts[num];
                }
            }

            const modes = [];
            for (const num in counts) {
                if (counts[num] === maxCount) {
                    modes.push(parseFloat(num));
                }
            }

            if (modes.length === arr.length) return 'N/A (No distinct mode)'; // All elements appear once
            return modes.sort((a, b) => a - b).map(m => m.toFixed(2)).join(', ');
        }

        function updateSummaryStatistics(data) {
            let totalUsageMinutes = 0;
            let totalKeystrokes = 0;
            let totalMouseMovements = 0;
            let totalMouseClicks = 0;
            let totalBreakDurations = 0; // This will now accumulate minutes directly
            const daysCount = data.length;

            let usageValues = [];
            let keystrokeValues = [];
            let mouseMovementValues = [];
            let mouseClickValues = [];
            let breakDurationValues = [];

            let maxUsage = 0;
            let minUsage = Infinity;

            let maxKeystrokes = 0;
            let minKeystrokes = Infinity;

            let maxMouseMovement = 0;
            let minMouseMovement = Infinity;

            let maxMouseClicks = 0;
            let minMouseClicks = Infinity;

            let maxBreakDuration = 0;
            let minBreakDuration = Infinity;

            data.forEach(entry => {
                const startDateTime = new Date(entry.start_date.year, entry.start_date.month, entry.start_date.day, entry.start_time.hour, entry.start_time.minute);
                const endDateTime = new Date(entry.end_date.year, entry.end_date.month, entry.end_date.day, entry.end_time.hour, entry.end_time.minute);
                const durationMs = endDateTime - startDateTime;
                const usageMinutes = durationMs / (1000 * 60);

                usageValues.push(usageMinutes);
                totalUsageMinutes += usageMinutes;
                if (usageMinutes > maxUsage) maxUsage = usageMinutes;
                if (usageMinutes > 0 && usageMinutes < minUsage) minUsage = usageMinutes; // Exclude 0 from min

                if (entry.activity_stats) {
                    const keystrokes = entry.activity_stats.keystrokes || 0;
                    const mouseMovements = entry.activity_stats.mouse_movement_units || 0;
                    const mouseClicks = entry.activity_stats.mouse_clicks || 0;

                    keystrokeValues.push(keystrokes);
                    totalKeystrokes += keystrokes;
                    if (keystrokes > maxKeystrokes) maxKeystrokes = keystrokes;
                    if (keystrokes > 0 && keystrokes < minKeystrokes) minKeystrokes = keystrokes; // Exclude 0 from min

                    mouseMovementValues.push(mouseMovements);
                    totalMouseMovements += mouseMovements;
                    if (mouseMovements > maxMouseMovement) maxMouseMovement = mouseMovements;
                    if (mouseMovements > 0 && mouseMovements < minMouseMovement) minMouseMovement = mouseMovements; // Exclude 0 from min

                    mouseClickValues.push(mouseClicks);
                    totalMouseClicks += mouseClicks;
                    if (mouseClicks > maxMouseClicks) maxMouseClicks = mouseClicks;
                    if (mouseClicks > 0 && mouseClicks < minMouseClicks) minMouseClicks = mouseClicks; // Exclude 0 from min
                }

                if (entry.break_stats && Array.isArray(entry.break_stats)) {
                    const dailyBreakDuration = entry.break_stats.reduce((sum, b) => sum + (b.values && b.values.length > 1 ? b.values[1] : 0), 0);
                    breakDurationValues.push(dailyBreakDuration);
                    totalBreakDurations += dailyBreakDuration;
                    if (dailyBreakDuration > maxBreakDuration) maxBreakDuration = dailyBreakDuration;
                    if (dailyBreakDuration > 0 && dailyBreakDuration < minBreakDuration) minBreakDuration = dailyBreakDuration; // Exclude 0 from min
                }
            });

            // Calculate Averages (using the total values calculated in the loop)
            const avgUsageMinutes = daysCount > 0 ? (totalUsageMinutes / daysCount) : 0;
            const avgUsageHours = avgUsageMinutes / 60;
            const avgKeystrokes = daysCount > 0 ? (totalKeystrokes / daysCount) : 0;
            const avgMouseMovement = daysCount > 0 ? (totalMouseMovements / daysCount) : 0;
            const avgMouseClicks = daysCount > 0 ? (totalMouseClicks / daysCount) : 0;
            const avgBreakDuration = daysCount > 0 ? (totalBreakDurations / daysCount) : 0;

            const maxUsageHours = maxUsage / 60;
            const minUsageHours = minUsage / 60;

            // Calculate Median and Mode
            const medianUsageMinutes = calculateMedian(usageValues);
            const medianUsageHours = medianUsageMinutes !== 'N/A' ? (medianUsageMinutes / 60) : 'N/A';
            const modeUsageMinutes = calculateMode(usageValues);
            const modeUsageHours = modeUsageMinutes !== 'N/A' && modeUsageMinutes.split(', ').every(val => !isNaN(parseFloat(val))) ? modeUsageMinutes.split(', ').map(val => (parseFloat(val) / 60).toFixed(2)).join(', ') : 'N/A';

            const medianKeystrokes = calculateMedian(keystrokeValues);
            const modeKeystrokes = calculateMode(keystrokeValues);

            const medianMouseMovement = calculateMedian(mouseMovementValues);
            const modeMouseMovement = calculateMode(mouseMovementValues);

            const medianMouseClicks = calculateMedian(mouseClickValues);
            const modeMouseClicks = calculateMode(mouseClickValues);

            const medianBreakDuration = calculateMedian(breakDurationValues);
            const modeBreakDuration = calculateMode(breakDurationValues);


            // Map of element IDs to update
            const summaryElements = new Map([
                ['summaryDaysCount', daysCount],
                ['avgDailyUsage', avgUsageMinutes.toFixed(2)],
                ['avgDailyUsageHours', avgUsageHours.toFixed(2)],
                ['medianDailyUsage', typeof medianUsageMinutes === 'number' ? medianUsageMinutes.toFixed(2) : medianUsageMinutes],
                ['medianDailyUsageHours', typeof medianUsageHours === 'number' ? medianUsageHours.toFixed(2) : medianUsageHours],
                ['modeDailyUsage', modeUsageMinutes],
                ['modeDailyUsageHours', modeUsageHours],
                ['maxDailyUsage', maxUsage.toFixed(2)],
                ['maxDailyUsageHours', maxUsageHours.toFixed(2)],
                ['minDailyUsage', minUsage !== Infinity ? minUsage.toFixed(2) : '0.00'],
                ['minDailyUsageHours', minUsageHours !== Infinity ? minUsageHours.toFixed(2) : '0.00'],
                ['avgDailyKeystrokes', Math.round(avgKeystrokes).toLocaleString()],
                ['medianDailyKeystrokes', typeof medianKeystrokes === 'number' ? Math.round(medianKeystrokes).toLocaleString() : medianKeystrokes],
                ['modeDailyKeystrokes', modeKeystrokes !== 'N/A (No distinct mode)' ? modeKeystrokes.split(', ').map(m => Math.round(parseFloat(m)).toLocaleString()).join(', ') : modeKeystrokes],
                ['maxDailyKeystrokes', maxKeystrokes.toLocaleString()],
                ['minDailyKeystrokes', minKeystrokes !== Infinity ? minKeystrokes.toLocaleString() : '0'],
                ['avgDailyMouseMovement', Math.round(avgMouseMovement).toLocaleString()],
                ['medianDailyMouseMovement', typeof medianMouseMovement === 'number' ? Math.round(medianMouseMovement).toLocaleString() : medianMouseMovement],
                ['modeDailyMouseMovement', modeMouseMovement !== 'N/A (No distinct mode)' ? modeMouseMovement.split(', ').map(m => Math.round(parseFloat(m)).toLocaleString()).join(', ') : modeMouseMovement],
                ['maxDailyMouseMovement', maxMouseMovement.toLocaleString()],
                ['minDailyMouseMovement', minMouseMovement !== Infinity ? minMouseMovement.toLocaleString() : '0'],
                ['avgDailyMouseClicks', Math.round(avgMouseClicks).toLocaleString()],
                ['medianDailyMouseClicks', typeof medianMouseClicks === 'number' ? Math.round(medianMouseClicks).toLocaleString() : medianMouseClicks],
                ['modeDailyMouseClicks', modeMouseClicks !== 'N/A (No distinct mode)' ? modeMouseClicks.split(', ').map(m => Math.round(parseFloat(m)).toLocaleString()).join(', ') : modeMouseClicks],
                ['maxDailyMouseClicks', maxMouseClicks.toLocaleString()],
                ['minDailyMouseClicks', minMouseClicks !== Infinity ? minMouseClicks.toLocaleString() : '0'],
                ['avgDailyBreakDuration', avgBreakDuration.toFixed(2)],
                ['medianDailyBreakDuration', typeof medianBreakDuration === 'number' ? medianBreakDuration.toFixed(2) : medianBreakDuration],
                ['modeDailyBreakDuration', modeBreakDuration],
                ['maxDailyBreakDuration', maxBreakDuration.toFixed(2)],
                ['minDailyBreakDuration', minBreakDuration !== Infinity ? minBreakDuration.toFixed(2) : '0.00'],
            ]);

            // Update text content for each element, with explicit null checks and logging
            summaryElements.forEach((value, id) => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                } else {
                    console.error(`Error: HTML element with ID '${id}' not found. Cannot update summary statistics.`);
                }
            });
        }

        function renderPlotlyCharts(data) {
            const dates = data.map(entry => {
                return `${entry.start_date.year}-${String(entry.start_date.month + 1).padStart(2, '0')}-${String(entry.start_date.day).padStart(2, '0')}`;
            });

            const isDarkMode = document.body.classList.contains('dark-mode');
            const chartBgColor = isDarkMode ? '#3a3a3a' : '#ffffff';
            const chartFontColor = isDarkMode ? '#e0e0e0' : '#343a40';
            const gridLineColor = isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';


            const commonLayoutProps = {
                font: {
                    color: chartFontColor
                },
                paper_bgcolor: chartBgColor,
                plot_bgcolor: chartBgColor,
                height: 350,
                margin: { t: 40, b: 80, l: 40, r: 40 },
                xaxis: {
                    gridcolor: gridLineColor,
                    zerolinecolor: gridLineColor,
                    automargin: true
                },
                yaxis: {
                    gridcolor: gridLineColor,
                    zerolinecolor: gridLineColor,
                    automargin: true
                }
            };

            const usageTimes = data.map(entry => {
                const startDateTime = new Date(entry.start_date.year, entry.start_date.month, entry.start_date.day, entry.start_time.hour, entry.start_time.minute);
                const endDateTime = new Date(entry.end_date.year, entry.end_date.month, entry.end_date.day, entry.end_time.hour, entry.end_time.minute);
                const durationMs = endDateTime - startDateTime;
                return durationMs / (1000 * 60);
            });

            const usageTrace = {
                x: dates,
                y: usageTimes,
                mode: 'lines+markers',
                name: 'Daily Usage (minutes)',
                line: { color: 'rgb(75, 192, 192)' },
                marker: { color: 'rgb(75, 192, 192)' }
            };
            const usageLayout = {
                title: 'Daily Computer Usage Time (Minutes)',
                ...commonLayoutProps
            };
            Plotly.newPlot('activityChart', [usageTrace], usageLayout);
            document.getElementById('activityChart').dataset.plotlyInitialised = 'true';


            const keystrokes = data.map(entry => entry.activity_stats ? entry.activity_stats.keystrokes : 0);
            const keystrokeTrace = {
                x: dates,
                y: keystrokes,
                mode: 'lines+markers',
                name: 'Keystrokes',
                line: { color: 'rgb(255, 99, 132)' },
                marker: { color: 'rgb(255, 99, 132)' }
            };
            const keystrokeLayout = {
                title: 'Daily Keystrokes',
                ...commonLayoutProps
            };
            Plotly.newPlot('keystrokeChart', [keystrokeTrace], keystrokeLayout);
            document.getElementById('keystrokeChart').dataset.plotlyInitialised = 'true';


            const mouseMovements = data.map(entry => entry.activity_stats ? entry.activity_stats.mouse_movement_units : 0);
            const mouseMovementTrace = {
                x: dates,
                y: mouseMovements,
                mode: 'lines+markers',
                name: 'Mouse Movement',
                line: { color: 'rgb(54, 162, 235)' },
                marker: { color: 'rgb(54, 162, 235)' }
            };
            const mouseMovementLayout = {
                title: 'Daily Mouse Movement (Units)',
                ...commonLayoutProps
            };
            Plotly.newPlot('mouseMovementChart', [mouseMovementTrace], mouseMovementLayout);
            document.getElementById('mouseMovementChart').dataset.plotlyInitialised = 'true';


            const mouseClicks = data.map(entry => entry.activity_stats ? entry.activity_stats.mouse_clicks : 0);
            const mouseClickTrace = {
                x: dates,
                y: mouseClicks,
                mode: 'lines+markers',
                name: 'Mouse Clicks',
                line: { color: 'rgb(255, 205, 86)' },
                marker: { color: 'rgb(255, 205, 86)' }
            };
            const mouseClickLayout = {
                title: 'Daily Mouse Clicks',
                ...commonLayoutProps
            };
            Plotly.newPlot('mouseClickChart', [mouseClickTrace], mouseClickLayout);
            document.getElementById('mouseClickChart').dataset.plotlyInitialised = 'true';


            const breakDurations = data.map(entry => {
                if (entry.break_stats && Array.isArray(entry.break_stats)) {
                    return entry.break_stats.reduce((sum, b) => sum + (b.values && b.values.length > 1 ? b.values[1] : 0), 0);
                }
                return 0;
            });

            const breakDurationTrace = {
                x: dates,
                y: breakDurations,
                mode: 'lines+markers',
                name: 'Total Break Duration (minutes)',
                line: { color: 'rgb(153, 102, 255)' },
                marker: { color: 'rgb(153, 102, 255)' }
            };
            const breakDurationLayout = {
                title: 'Daily Total Break Duration (Minutes)',
                ...commonLayoutProps
            };
            Plotly.newPlot('breakDurationChart', [breakDurationTrace], breakDurationLayout);
            document.getElementById('breakDurationChart').dataset.plotlyInitialised = 'true';
        }

        function runCustomQuery() {
            const queryInput = document.getElementById('customQueryInput').value.trim();
            const queryResultsDiv = document.getElementById('queryResults');
            queryResultsDiv.textContent = ''; // Clear previous results
            lastQueryResults = []; // Clear previous query results for download

            if (!queryInput) {
                queryResultsDiv.textContent = 'Please enter a query.';
                return;
            }

            if (currentFilteredData.length === 0) {
                queryResultsDiv.textContent = 'No data available to query. Adjust filters or check data source.';
                return;
            }

            // Regex to parse queries like "metric > value" or "metric <= value"
            const queryRegex = /^\s*([a-zA-Z_]+)\s*([<>=!]+)\s*(\d+(\.\d+)?)\s*$/;
            const match = queryInput.match(queryRegex);

            if (!match) {
                queryResultsDiv.textContent = 'Invalid query format. Please use "metric operator value" (e.g., "usage > 300").';
                return;
            }

            const metricName = match[1].toLowerCase();
            const operator = match[2];
            const value = parseFloat(match[3]);

            if (isNaN(value)) {
                queryResultsDiv.textContent = 'Invalid numeric value in query.';
                return;
            }

            let matchingDays = [];
            let errorFound = false;

            currentFilteredData.forEach(entry => {
                let metricValue;
                let dateString = `${entry.start_date.year}-${String(entry.start_date.month + 1).padStart(2, '0')}-${String(entry.start_date.day).padStart(2, '0')}`;

                switch (metricName) {
                    case 'usage':
                        const startDateTime = new Date(entry.start_date.year, entry.start_date.month, entry.start_date.day, entry.start_time.hour, entry.start_time.minute);
                        const endDateTime = new Date(entry.end_date.year, entry.end_date.month, entry.end_date.day, entry.end_time.hour, entry.end_time.minute);
                        const durationMs = endDateTime - startDateTime;
                        metricValue = durationMs / (1000 * 60); // minutes
                        break;
                    case 'keystrokes':
                        metricValue = entry.activity_stats ? (entry.activity_stats.keystrokes || 0) : 0;
                        break;
                    case 'mouse_movement':
                        metricValue = entry.activity_stats ? (entry.activity_stats.mouse_movement_units || 0) : 0;
                        break;
                    case 'mouse_clicks':
                        metricValue = entry.activity_stats ? (entry.activity_stats.mouse_clicks || 0) : 0;
                        break;
                    case 'break_duration':
                        metricValue = (entry.break_stats && Array.isArray(entry.break_stats)) ?
                                      entry.break_stats.reduce((sum, b) => sum + (b.values && b.values.length > 1 ? b.values[1] : 0), 0) : 0; // minutes
                        break;
                    default:
                        queryResultsDiv.textContent = `Unknown metric: '${metricName}'. Please use one of: usage, keystrokes, mouse_movement, mouse_clicks, break_duration.`;
                        errorFound = true;
                        return; // Exit forEach
                }

                if (errorFound) return;

                let conditionMet = false;
                switch (operator) {
                    case '>':
                        conditionMet = metricValue > value;
                        break;
                    case '<':
                        conditionMet = metricValue < value;
                        break;
                    case '>=':
                        conditionMet = metricValue >= value;
                        break;
                    case '<=':
                        conditionMet = metricValue <= value;
                        break;
                    case '==':
                    case '=': // Allow single equals for equality
                        conditionMet = metricValue === value;
                        break;
                    case '!=':
                        conditionMet = metricValue !== value;
                        break;
                    default:
                        queryResultsDiv.textContent = `Unsupported operator: '${operator}'. Please use one of: >, <, >=, <=, ==, !=.`;
                        errorFound = true;
                        return; // Exit forEach
                }

                if (errorFound) return;

                if (conditionMet) {
                    matchingDays.push({
                        date: dateString,
                        metric: metricName,
                        value: metricValue.toFixed(2),
                        query: queryInput // Store the query itself
                    });
                }
            });

            if (errorFound) return; // Stop if an error occurred during iteration

            lastQueryResults = matchingDays; // Store results for download

            if (matchingDays.length > 0) {
                const formattedResults = matchingDays.map(day => `${day.date}: ${day.metric} = ${day.value}`).join('<br>');
                queryResultsDiv.innerHTML = `Found ${matchingDays.length} day(s) where ${queryInput}:<br>${formattedResults}`;
            } else {
                queryResultsDiv.textContent = `No days found matching the query "${queryInput}".`;
            }
        }

        function downloadQueryResults() {
            if (lastQueryResults.length === 0) {
                alert("No query results to download. Please run a query first.");
                return;
            }

            const header = "Date,Metric,Value,Query\n";
            const csvRows = lastQueryResults.map(row => `${row.date},${row.metric},${row.value},"${row.query.replace(/"/g, '""')}"`);
            const csvContent = header + csvRows.join("\n");

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', 'workrave_query_results.csv');
            link.style.visibility = 'hidden'; // Hide the link
            document.body.appendChild(link); // Add to DOM briefly
            link.click(); // Trigger download
            document.body.removeChild(link); // Clean up
            URL.revokeObjectURL(url); // Release the URL object
        }


        document.addEventListener('DOMContentLoaded', async () => {
            // Load filter state first
            loadFilterState();
            
            // Set default dates if not loaded from localStorage
            if (!document.getElementById('startDate').value) {
                document.getElementById('startDate').value = DEFAULT_START_DATE;
            }
            if (!document.getElementById('endDate').value) {
                document.getElementById('endDate').value = DEFAULT_END_DATE;
            }

            await fetchInitialData();

            const selectAllFiltersCheckbox = document.getElementById('selectAllFilters');
            const individualFilterCheckboxes = getIndividualFilterCheckboxes();

            function updateSelectAllCheckbox() {
                const allChecked = individualFilterCheckboxes.every(cb => cb.checked);
                selectAllFiltersCheckbox.checked = allChecked;
            }

            // Event Listeners for Filters
            document.getElementById('startDate').addEventListener('change', applyFiltersAndRenderCharts);
            document.getElementById('endDate').addEventListener('change', applyFiltersAndRenderCharts);

            selectAllFiltersCheckbox.addEventListener('change', () => {
                const isChecked = selectAllFiltersCheckbox.checked;
                individualFilterCheckboxes.forEach(cb => {
                    cb.checked = isChecked;
                });
                applyFiltersAndRenderCharts();
            });

            individualFilterCheckboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    updateSelectAllCheckbox();
                    applyFiltersAndRenderCharts();
                });
            });

            // Dark Mode Toggle
            const darkModeToggle = document.getElementById('darkModeToggle');
            // The dark mode state is already loaded by loadFilterState(), just need to ensure body class is correct
            // if (localStorage.getItem('darkMode') === 'true') { // This check is now redundant due to loadFilterState
            //     document.body.classList.add('dark-mode');
            // }

            darkModeToggle.addEventListener('change', () => {
                if (darkModeToggle.checked) {
                    document.body.classList.add('dark-mode');
                    localStorage.setItem('darkMode', 'true');
                } else {
                    document.body.classList.remove('dark-mode');
                    localStorage.setItem('darkMode', 'false');
                }
                applyFiltersAndRenderCharts(); // Re-render charts for theme
            });

            // Custom Query Listener
            document.getElementById('runQueryButton').addEventListener('click', runCustomQuery);
            document.getElementById('customQueryInput').addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    runCustomQuery();
                }
            });

            // Download Query Results Listener
            document.getElementById('downloadQueryResultsButton').addEventListener('click', downloadQueryResults);

            // Initial render - this will now use the loaded filter states
            applyFiltersAndRenderCharts();
            updateSelectAllCheckbox(); // Update select all checkbox based on loaded state
        });
    </script>
</body>
</html>
